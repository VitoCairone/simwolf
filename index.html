<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SimWolf</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body, html { height: 100%; overflow: hidden; background-color: #222; }
    #app { display: flex; height: 100%; }
    #sidebar {
      width: 150px;
      background: #333;
      color: white;
      display: flex;
      flex-direction: column;
      padding: 15px;
      gap: 10px;
      border-right: 2px solid #444;
    }
    #sidebar button {
      padding: 10px;
      background-color: #555;
      color: white;
      border: 1px solid #666;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.3s;
    }
    #sidebar button:hover { background-color: #777; }
    #field-wrapper {
      flex: 1;
      position: relative;
      overflow: hidden;
      background-color: #9dd4f3;
    }
    #field {
      position: absolute;
      top: 0;
      left: 0;
      width: 3000px;
      height: 3000px;
      will-change: transform;
      transform: translate(0px, 0px);
    }
    .tile {
      /* border: 1px solid green; */
      position: absolute;
      width: 32px;
      height: 32px;
      background-image: url('./images_raw/tiles.png');
      background-repeat: no-repeat;
      background-size: auto;
      image-rendering: pixelated;
    }
    #wolf {
      position: absolute;
      width: 64px;
      height: 64px;
      background-image: url('./images/wolf-run-stand.png');
      background-repeat: no-repeat;
      image-rendering: pixelated;
    }
    #tile-layer, #sprite-layer {
      position: absolute;
      top: 0;
      left: 0;
    }
    #tile-layer { z-index: 1; }
    #sprite-layer { z-index: 2; }

    /* Tile types */
    .tile.dirt      { background-position:   0px     0px; }
    .tile.grass     { background-position:   0px   -64px; }
    .tile.bush      { background-position:   0px   -96px; }
    .tile.tallgrass { background-position: -160px  -96px; }
    .tile.flower    { background-position: -256px  -96px; }
    .tile.rock      { background-position: -288px -128px; }
    .tile.stone     { background-position: -192px -160px; }
    .tile.water     { background-position:   0px  -256px; }
    .tile.ice       { background-position:   0px  -320px; }
  </style>
</head>
<body>
  <div id="app">
    <div id="sidebar">
      <button>Tool 1</button>
      <button>Tool 2</button>
      <div id="cursor-coords" style="margin-top: auto; font-size: 12px; color: #aaa;">
        x: –, y: –
      </div>
    </div>
    <div id="field-wrapper">
      <div id="field">
        <div id="tile-layer"></div>
        <div id="sprite-layer"><div id="wolf"></div></div>
      </div>
    </div>
  </div>

  <script>
    const tileLayer = document.getElementById("tile-layer");
    const wolfElement = document.getElementById('wolf');

    // parameters
    const tileSize = 32;
    const tileRiserPx = 8;
    const gridWidthN = 128;
    const gridHeightN = 128;
    const wolfFramePx = 64;
    const wolfFrameShadowPY = 39;

    // derived constants, set once on startup
    const halfTile = tileSize / 2;
    const qtrTile = tileSize / 4;
    const [gridRadHoriz, gridDiamVert] = isoPxProject(gridWidthN, gridHeightN);

    // when source becomes multiple files, read this sort of fixed data from its own file
    const tileMap = [
      ["dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt"],
      ["dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt"],
      ["grass", "grass", "grass", "dirt", "dirt", "grass", "grass", "plant", "plant", "plant", "plant"],
      ["bush", "bush", "bush", "bush", "grass", "tallgrass", "tallgrass", "grass", "+ flower", "+ flower", "+ bush"],
      ["+ flower", "+ bush", "+ flower", "+ flower", "+ log", "+ log", "+ log", "+ log", "+ log", "+ rock", "+ rock"],
      ["+ rock", "+ rock", "+ rock", "+ rock", "+ rock", "+ rock", "stone", "+ stone", "stone", "rock", "rock"],
      ["+ rock", "+ rock", "w-stone", "w-stone", "w-rock", "w-rock", "w-rock", "w-rock", "w-rock", "w-rock", "w-rock"],
      ["w-rock", "w-rock", "w-rock", "w-rock", "w-rock", "splash", "splash", "splash", "splash", null, null],
      ["water", "water", "water", "water", "water", "water", "water", "water", "water", null, null],
      ["water", "water", "water", "water", "water", "water", "water", "water", "water", null, null],
      ["ice", "ice", "ice", "ice", "ice", "ice", "ice", "ice", "ice", "ice", "ice"]
    ];

    const terrainTypes = [
      "dirt", "grass", "bush", "tallgrass", "flower", "rock", "stone", "water", "ice"
    ];

    let wolfGX = Math.floor(gridWidthN / 2) + 0.5;
    let wolfGY = Math.floor(gridHeightN / 2) + 0.5;

    let wolfVelocityGX = 0;
    let wolfVelocityGY = 0;
    let currentDirection = 0;
    let isMoving = false;

    const wolfMovementSpeed = 300 / 60; // unit: tile/frame
    let currentWolfFrame = 0;
    let wolfAnimTimer = 0;

    let cameraPX = 0;
    let cameraPY = 0;
    const cameraSpeed = 10;
    const keysPressed = {};

    const movementDirections = [
      { dx: 0, dy: 1, dir: 0 },
      { dx: 1, dy: 0, dir: 1 },
      { dx: -1, dy: 0, dir: 2 },
      { dx: 0, dy: -1, dir: 3 }
    ];

    function generateField() {
      const [initialWolfPX, initialWolfPY] = isoPxProject(wolfGX, wolfGY);
      const viewportWidth = document.getElementById('field-wrapper').clientWidth;
      const viewportHeight = document.getElementById('field-wrapper').clientHeight;

      cameraPX = initialWolfPX - viewportWidth / 2;
      cameraPY = initialWolfPY - halfTile - viewportHeight / 2;

      // We'll offset all our tiles a bit so that the ground point on the top of the screen,
      // for a flat terrain, is exactly the grid point (0, 0).
      const leftTileOffsetC = -halfTile;
      const topTileOffsetC = -tileRiserPx;

      for (let r = 0; r < gridHeightN; r++) {
        for (let c = 0; c < gridWidthN; c++) {
          const tile = document.createElement("div");
          tile.classList.add("tile");

          const [isoX, isoY] = isoPxProject(c, r);

          tile.style.left = (isoX + leftTileOffsetC) + "px";
          tile.style.top = (isoY + topTileOffsetC) + "px" ;
          tile.style.zIndex = c + r;

          const randomType = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
          tile.classList.add(randomType);
          tile.dataset.type = randomType;

          tileLayer.appendChild(tile);
        }
      }
      updateCamera();
    }

    function updateCamera() {
      // TODO: prevent this from being called constantly when the camera is not moving
      // TODO: resolve issue with camera locked horizontally at center using -gradRadHoriz
      console.log(cameraPX);
      console.log(cameraPY);
      console.log(gridRadHoriz);
      console.log(gridDiamVert);
      cameraPX = Math.max(-Infinity, Math.min(gridRadHoriz, cameraPX));
      cameraPY = Math.max(0, Math.min(gridDiamVert, cameraPY));
      document.getElementById("field").style.transform = `translate(${-cameraPX}px, ${-cameraPY}px)`;
    }

    function isoPxProject(x, y) {
      const isoX = (x - y) * halfTile;
      const isoY = (x + y) * qtrTile;
      return [isoX, isoY];
    }

    function rectiGxProject(px, py) {
      const gx = (px / tileSize + py / halfTile);
      const gy = (py / halfTile - px / tileSize);
      return [gx, gy];
    }

    function gameLoop() {
      if (keysPressed["ArrowUp"]) cameraPY -= cameraSpeed;
      if (keysPressed["ArrowDown"]) cameraPY += cameraSpeed;
      if (keysPressed["ArrowLeft"]) cameraPX -= cameraSpeed;
      if (keysPressed["ArrowRight"]) cameraPX += cameraSpeed;
      updateCamera();

      wolfAnimTimer++;
      if (wolfAnimTimer >= (isMoving ? 5 : 12)) {
        wolfAnimTimer = 0;
        currentWolfFrame++;
        const maxFrame = isMoving ? 8 : 4;
        currentWolfFrame %= maxFrame;
        const frameCol = isMoving ? currentWolfFrame : (currentWolfFrame + 8);
        wolfElement.style.backgroundPosition =
          `-${frameCol * wolfFramePx}px -${currentDirection * wolfFramePx}px`;
      }

      const nextGX = wolfGX + wolfVelocityGX;
      const nextGY = wolfGY + wolfVelocityGY;

      if (nextGX >= 0 && nextGX < gridWidthN && nextGY >= 0 && nextGY < gridHeightN) {
        wolfGX = nextGX;
        wolfGY = nextGY;
        isMoving = (wolfVelocityGX !== 0 || wolfVelocityGY !== 0);
      } else {
        wolfVelocityGX = 0;
        wolfVelocityGY = 0;
        isMoving = false;
      }

      const [isoX, isoY] = isoPxProject(wolfGX, wolfGY);

      const topWolfOffsetC = wolfFramePx - wolfFrameShadowPY;
      wolfElement.style.left = (isoX - wolfFramePx / 2) + "px";
      wolfElement.style.top = (isoY - topWolfOffsetC) + "px";
      wolfElement.style.zIndex = Math.floor(wolfGX + wolfGY) + 0.5;

      requestAnimationFrame(gameLoop);
    }

    function addCursorTracker() {
      const fieldWrapper = document.getElementById("field-wrapper");
      const cursorCoords = document.getElementById("cursor-coords");

      fieldWrapper.addEventListener("mousemove", (e) => {
        const rect = fieldWrapper.getBoundingClientRect();
        const mousePX = e.clientX - rect.left + cameraPX;
        const mousePY = e.clientY - rect.top + cameraPY;

        const mouseGX = (mousePX / halfTile + mousePY / qtrTile) / 2;
        const mouseGY = (mousePY / qtrTile - mousePX / halfTile) / 2;

        // TODO: display out-of-bounds coords in red, normal in black
        if (mouseGX >= 0 && mouseGX < gridWidthN && mouseGY >= 0 && mouseGY < gridHeightN) {
          const [dispGX, dispGY] = [mouseGX.toFixed(3), mouseGY.toFixed(3)];
          cursorCoords.textContent = `x: ${dispGX}, y: ${dispGY}`;
        } else {
          cursorCoords.textContent = `x: –, y: –`;
        }
      });

      fieldWrapper.addEventListener("mouseleave", () => {
        cursorCoords.textContent = `x: –, y: –`;
      });
    }

    setInterval(() => {
      if (Math.random() < 0.2) {
        wolfVelocityGX = 0;
        wolfVelocityGY = 0;
        isMoving = false;
        return;
      }

      const dir = movementDirections[Math.floor(Math.random() * movementDirections.length)];
      const testGridX = Math.round(wolfGX + dir.dx);
      const testGridY = Math.round(wolfGY + dir.dy);

      // const tiles = document.elementsFromPoint(
      //   (testGridX - testGridY) * (tileSize / 2) - cameraPX,
      //   (testGridX + testGridY) * (tileSize / 4) - cameraPY
      // );

      // const nextTile = tiles.find(el => el.classList.contains("tile"));
      // const terrain = nextTile?.dataset.type || "unknown";

      // const impassable = ["rock", "stone", "wstone", "wrock", "splash", "water", "ice"];

      // if (!impassable.includes(terrain)) {

        wolfVelocityGX = dir.dx * wolfMovementSpeed;
        wolfVelocityGY = dir.dy * wolfMovementSpeed;
        currentDirection = dir.dir;
        isMoving = true;

      // } else {
      //   wolfVelocityGX = 0;
      //   wolfVelocityGY = 0;
      //   isMoving = false;
      // }
    }, 2000);

    document.addEventListener("keydown", (e) => { keysPressed[e.key] = true; });
    document.addEventListener("keyup", (e) => { keysPressed[e.key] = false; });

    window.onload = function () {
      generateField();
      gameLoop();
      addCursorTracker();
    };
  </script>
</body>
</html>