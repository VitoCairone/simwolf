<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SimWolf</title>
  <link rel="icon" type="image/png" href="./images/wolf-icon.png" sizes="32x32">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body, html { height: 100%; overflow: hidden; background-color: #222; }
    #app { display: flex; height: 100%; }
    #sidebar {
      width: 150px;
      background: #333;
      color: white;
      display: flex;
      flex-direction: column;
      padding: 15px;
      gap: 10px;
      border-right: 2px solid #444;
    }
    #sidebar button {
      padding: 10px;
      background-color: #555;
      color: white;
      border: 1px solid #666;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.3s;
    }
    #sidebar button:hover:not(:disabled) { background-color: #777; }
    #sidebar button:disabled {
      background-color: #444;
      color: #777;
      cursor: default;
    }
    .zoom-buttons {
      display: flex;
      gap: 5px;
      width: 100%;
    }
    .zoom-buttons button {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10px;
    }
    #field-wrapper {
      flex: 1;
      position: relative;
      overflow: hidden;
      background-color: #9dd4f3;
    }
    #field {
      position: absolute;
      top: 0;
      left: 0;
      width: 3000px;
      height: 3000px;
      will-change: transform;
      transform: translate(0px, 0px) scale(1);
      transform-origin: top left;
      image-rendering: pixelated;
    }
    .tile {
      position: absolute;
      width: 32px;
      height: 32px;
      background-image: url('./images/tiles.png');
      background-repeat: no-repeat;
      background-size: auto;
      image-rendering: pixelated;
    }
    .wolf {
      position: absolute;
      width: 64px;
      height: 64px;
      background-image: url('./images/wolf-run-stand.png');
      background-repeat: no-repeat;
      image-rendering: pixelated;
    }
    .deer {
      position: absolute;
      width: 32px;
      height: 41px;
      background-image: url('./images/stag-walk-idle.png');
      background-repeat: no-repeat;
      image-rendering: pixelated;
    }
    #tile-layer, #sprite-layer {
      position: absolute;
      top: 0;
      left: 0;
    }
    #tile-layer { z-index: 1; }
    #sprite-layer { z-index: 2; }
    .tile.dirt      { background-position:   0px     0px; }
    .tile.grass     { background-position:   0px   -64px; }
    .tile.bush      { background-position:   0px   -96px; }
    .tile.tallgrass { background-position: -160px  -96px; }
    .tile.flower    { background-position: -256px  -96px; }
    .tile.rock      { background-position: -288px -128px; }
    .tile.stone     { background-position: -192px -160px; }
    .tile.water     { background-position:   0px  -256px; }
    .tile.ice       { background-position:   0px  -320px; }
  </style>
</head>
<body>
  <div id="app">
    <div id="sidebar">
      <button id="arrow-mode-toggle">
        <svg id="arrow-keys-placeholder" width="26" height="26" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="1">
          <!-- Up arrow -->
          <path d="M12 2 L9 6 H11 V10 H13 V6 H15 Z" />
          <!-- Down arrow -->
          <path d="M12 22 L9 18 H11 V14 H13 V18 H15 Z" />
          <!-- Left arrow -->
          <path d="M2 12 L6 9 V11 H10 V13 H6 V15 Z" />
          <!-- Right arrow -->
          <path d="M22 12 L18 9 V11 H14 V13 H18 V15 Z" />
        </svg>
        <svg id="arrow-mode-icon" width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <!-- SVG set by script on page load -->
        </svg>
      </button>

      <div class="zoom-buttons">
        <button id="zoom-in" aria-label="Zoom In">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="9"/>
            <line x1="12" y1="8" x2="12" y2="16"/>
            <line x1="8" y1="12" x2="16" y2="12"/>
          </svg>
        </button>

        <button id="zoom-out" aria-label="Zoom Out">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="9"/>
            <line x1="8" y1="12" x2="16" y2="12"/>
          </svg>
        </button>

      </div>
      <div id="cursor-coords" style="margin-top: auto; font-size: 12px; color: #aaa;">
        x: –, y: –
      </div>
    </div>
    <div id="field-wrapper">
      <div id="field">
        <div id="tile-layer"></div>
        <div id="sprite-layer"></div>
      </div>
    </div>
  </div>

  <script>
    const fieldElement = document.getElementById("field");
    const tileLayer = document.getElementById("tile-layer");
    const spriteLayer = document.getElementById("sprite-layer");
    const zoomInBtn = document.getElementById("zoom-in");
    const zoomOutBtn = document.getElementById("zoom-out");

    let zoomLevel = 1;
    const zoomMin = 0.5;
    const zoomMax = 8;

    // parameters
    const tileSize = 32;
    const tileRiserPY = 8;
    const gridWidthN = 128;
    const gridHeightN = 128;
    const deerFrameW = 32;
    const deerFrameH = 41;

    // derived constants, set once on startup

    // Note that a tile which is SQUARE in grid space appears as a SQUASHED DIAMOND
    // in isometric, with the surface height pixels being 1/2 of the surface width pixels
    const halfTile = tileSize / 2;
    const qtrTile = tileSize / 4;
    const worldRadPX = halfTile + (gridWidthN + gridHeightN - 2) * qtrTile;
    const worldDiamPY = worldRadPX;

    // when source becomes multiple files, read this sort of fixed data from its own file
    const tileMap = [
      ["dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt"],
      ["dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt", "dirt"],
      ["grass", "grass", "grass", "dirt", "dirt", "grass", "grass", "plant", "plant", "plant", "plant"],
      ["bush", "bush", "bush", "bush", "grass", "tallgrass", "tallgrass", "grass", "+ flower", "+ flower", "+ bush"],
      ["+ flower", "+ bush", "+ flower", "+ flower", "+ log", "+ log", "+ log", "+ log", "+ log", "+ rock", "+ rock"],
      ["+ rock", "+ rock", "+ rock", "+ rock", "+ rock", "+ rock", "stone", "+ stone", "stone", "rock", "rock"],
      ["+ rock", "+ rock", "w-stone", "w-stone", "w-rock", "w-rock", "w-rock", "w-rock", "w-rock", "w-rock", "w-rock"],
      ["w-rock", "w-rock", "w-rock", "w-rock", "w-rock", "splash", "splash", "splash", "splash", null, null],
      ["water", "water", "water", "water", "water", "water", "water", "water", "water", null, null],
      ["water", "water", "water", "water", "water", "water", "water", "water", "water", null, null],
      ["ice", "ice", "ice", "ice", "ice", "ice", "ice", "ice", "ice", "ice", "ice"]
    ];

    const terrainTypes = [
      "dirt", "grass", "bush", "tallgrass", "flower", "rock", "stone", "water", "ice"
    ];

    const wolfIconSVG = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <!-- Face outline: top, left, right, bottom point -->
      <path d="M6 6 H18 V18 L12 22 L6 18 Z" />
      <!-- Ears: verticals -->
      <line x1="7" y1="6" x2="7" y2="3" />
      <line x1="17" y1="6" x2="17" y2="3" />
      <!-- Ears: angled tops -->
      <line x1="7" y1="3" x2="10" y2="6" />
      <line x1="17" y1="3" x2="14" y2="6" />
    </svg>`;

    const cameraIconSVG = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <!-- Main camera body: rounded rectangle -->
      <rect x="3" y="6" width="10" height="12" rx="2" ry="2" />
      <!-- Right-facing lens hood / extension -->
      <path d="M13 10 L17 7 V17 L13 14 Z" />
    </svg>`


    function isoProject(gx, gy) {
      const px = (gx - gy) * halfTile;
      const py = (gx + gy) * qtrTile;
      return [px, py];
    }

    function rectiProject(px, py) {
      const gx = (px / tileSize + py / halfTile);
      const gy = (py / halfTile - px / tileSize);
      return [gx, gy];
    }

    function boundVal(val, min, max) {
      return Math.max(min, Math.min(val, max));
    }

    // TODO: consider what data should be allowed to vary by pose and what data is fixed for the species
    const frameDataBySpeciesAndPose = {
      wolf: { 
        'walk': {nFrames: 8, colZero: 0, frameW: 64, frameH: 64, holdTks: 5, topToShadow: 39},
        'idle': {nFrames: 4, colZero: 8, frameW: 64, frameH: 64, holdTks: 12, topToShadow: 39} 
      },
      deer: { 
        'walk': {nFrames: 11, colZero: 0, frameW: 32, frameH: 41, holdTks: 5, topToShadow: 33},
        'idle': {nFrames: 24, colZero: 11, frameW: 32, frameH: 41, holdTks: 12, topToShadow: 33} 
      }
    }

    // converts miles per hour to tiles per tick
    function mphToSpeed(x) { return x * 1609.34 / 216000 }

    const wolfSprintSpeed = mphToSpeed(37); // < 1 minute sustain
    const wolfRunSpeed = mphToSpeed(6.0); // 20 minutes sustain
    const wolfWalkSpeed = mphToSpeed(4.5); // 10 hr sustain

    const deerSprintSpeed = mphToSpeed(43); // < 1 minute sustain
    const deerRunSpeed = mphToSpeed(31); // 2-3 minutes sustain
    const deerWalkSpeed = mphToSpeed(3.0); // 10 hr sustain

    function updateCritterFrame(wolf) {
      wolf.animTimer = 0;
      const frameData = frameDataBySpeciesAndPose[wolf.species][wolf.pose];
      wolf.frame = (wolf.frame + 1) % frameData.nFrames;
      // if (wolf.species === "deer") console.log(wolf.frame);
      const frameCol = frameData.colZero + wolf.frame;
      wolf.element.style.backgroundPosition =
        `-${frameCol * frameData.frameW}px -${wolf.currentDirection * frameData.frameH}px`;
    }

    function placeCritterSprite(wolf) {
      const [isoX, isoY] = isoProject(wolf.gx, wolf.gy);

      // wolf image is offset so its noon-shadow center is at its grid coordinate
      const frameData = frameDataBySpeciesAndPose[wolf.species][wolf.pose];
      const leftOffset = frameData.frameW / 2;
      const topOffset = frameData.frameH - (frameData.topToShadow || 0);

      wolf.element.style.left = (isoX - leftOffset) + "px";
      wolf.element.style.top = (isoY - topOffset) + "px";
      wolf.element.style.zIndex = Math.floor(wolf.gx + wolf.gy) + 0.5;
    }

    // Wolf setup
    const nWolves = 30;
    const wolves = Array.from({length: nWolves}, () => ({}));

    const nDeer = 30;
    const deer = Array.from({length: nDeer}, () => ({}));
    
    // in this and other Critter function, the parameter name used is wolf,
    // although it could be any critter
    function initCritter(wolf, species) {
      const el = document.createElement("div");
      el.classList.add(species);
      spriteLayer.appendChild(el);
      wolf.element = el;

      // start wolves on tile centers
      wolf.species = species;
      wolf.gx = Math.floor(Math.random() * gridWidthN) + 0.5;
      wolf.gy = Math.floor(Math.random() * gridHeightN) + 0.5;
      wolf.animTimer = 0;
      wolf.currentDirection = 0;
      wolf.frame = 0;
      setCritterIdle(wolf);

      updateCritterFrame(wolf);
      placeCritterSprite(wolf);
    }

    wolves.forEach(wolf => { initCritter(wolf, "wolf"); });
    deer.forEach(aDeer => { initCritter(aDeer, "deer"); });

    const allCritters = wolves.concat(deer);
    const pcWolf = wolves[0];

    // these are coordinates for the upper-left corner of the viewport
    let cameraPX = 0;
    let cameraPY = 0;
    const cameraSpeed = 10;
    const keysPressed = {};

    const movementDirections = [
      { dx: 0, dy: -1, dir: 0 },
      { dx: 1, dy: 0, dir: 1 },
      { dx: 0, dy: 1, dir: 2 },
      { dx: -1, dy: 0, dir: 3 }
    ];

    const viewportWidth = document.getElementById('field-wrapper').clientWidth;
    const viewportHeight = document.getElementById('field-wrapper').clientHeight;

    const arrowKeyNames = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
    const arrowsToggle = document.getElementById('arrow-mode-toggle');
    const arrowsIcon = document.getElementById('arrow-mode-icon');
    arrowsIcon.innerHTML = cameraIconSVG;

    let arrowsMoveWolf = false;

    arrowsToggle.addEventListener('click', () => {
      arrowsMoveWolf = !arrowsMoveWolf;
      arrowsIcon.innerHTML = arrowsMoveWolf ? wolfIconSVG : cameraIconSVG;
    });

    function updateZoomButtons() {
      zoomInBtn.disabled = zoomLevel >= zoomMax;
      zoomOutBtn.disabled = zoomLevel <= zoomMin;
    }

    zoomInBtn.addEventListener("click", () => {
      if (zoomLevel < zoomMax) {
        zoomLevel *= 2;
        updateCamera();
        updateZoomButtons();
      }
    });

    zoomOutBtn.addEventListener("click", () => {
      if (zoomLevel > zoomMin) {
        zoomLevel /= 2;
        updateCamera();
        updateZoomButtons();
      }
    });

    updateZoomButtons();

    function generateField() {
      // All our tiles images are offset so that the single point on the top of the world's
      // isometric diamond, for a flat terrain, is exactly the grid point (0, 0).
      const leftTileOffsetC = -halfTile;
      const topTileOffsetC = -tileRiserPY;

      for (let r = 0; r < gridHeightN; r++) {
        for (let c = 0; c < gridWidthN; c++) {
          const tile = document.createElement("div");
          tile.classList.add("tile");

          const [isoX, isoY] = isoProject(c, r);

          tile.style.left = (isoX + leftTileOffsetC) + "px";
          tile.style.top = (isoY + topTileOffsetC) + "px" ;
          tile.style.zIndex = c + r;

          const randomType = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
          // tile.classList.add(randomType);
          tile.classList.add("dirt");
          tile.style.backgroundPositionX = `${-tileSize * Math.floor(Math.random() * 11)}px`
          tile.dataset.type = randomType;

          tileLayer.appendChild(tile);
        }
      }
      updateCamera();
    }

    function updateCamera() {
      // TODO: ensure camera remains centered on zoom in and out
      cameraPX = boundVal(cameraPX, -worldRadPX * zoomLevel, worldRadPX * zoomLevel - viewportWidth);
      cameraPY = boundVal(cameraPY, 0, (worldDiamPY + tileRiserPY) * zoomLevel - viewportHeight);
      document.getElementById("field").style.transform = `translate(${-cameraPX}px, ${-cameraPY}px) scale(${zoomLevel})`;
    }

    function updateAllCritters() {
      allCritters.forEach(wolf => {
        wolf.animTimer++;
        let holdTks = frameDataBySpeciesAndPose[wolf.species][wolf.pose].holdTks;
        if (wolf.animTimer >= holdTks) updateCritterFrame(wolf);

        if (wolf.velGX === 0 && wolf.velGY === 0) {
          wolf.nextGX = wolf.gx;
          wolf.nextGY = wolf.gy;
          return;
        }

        const nextGX = wolf.gx + wolf.velGX;
        const nextGY = wolf.gy + wolf.velGY;
        if (nextGX >= 0.6 && nextGX < (gridWidthN - 0.6) && nextGY >= 0.6 && nextGY < (gridHeightN - 0.6)) {
          wolf.nextGX = nextGX;
          wolf.nextGY = nextGY;
        } else {
          setCritterIdle(wolf);
        }
      });

      moveAllTogether(allCritters);
    }

    function moveAllTogether(movers) {
      // lazy first pass: halt colliders
      const collidePairs = findCollidingPairs(movers);
      // console.log(collidePairs);
      const didCollide = {};
      collidePairs.forEach(pair => pair.forEach(m => didCollide[m] = true));
      console.log(Object.keys(didCollide));
      movers.forEach((mover, idx) => {
        // TODO: consider if this check is necessary and why?
        if (mover.nextGX === mover.gx && mover.nextGY === mover.gy) return;

        // TODO: Fix this logic, once halted a creature is never able to escape...
        if (didCollide[idx]) {
          // this mover's gx and gy do NOT get updated
          setCritterIdle(mover);
        } else {
          mover.gx = mover.nextGX;
          mover.gy = mover.nextGY;
          placeCritterSprite(mover);
        }
      });
    }

    function gameLoop() {
      let hasInput = arrowKeyNames.some(ak => keysPressed[ak]);
      if (hasInput) {
        if (arrowsMoveWolf) {
          // for simplicity, the arrow keys currently move along grid axis and don't combine
          if (keysPressed["ArrowUp"]) { setCritterMoving(pcWolf, movementDirections[3]); }
          if (keysPressed["ArrowDown"]) { setCritterMoving(pcWolf, movementDirections[0]); }
          if (keysPressed["ArrowLeft"]) { setCritterMoving(pcWolf, movementDirections[2]); }
          if (keysPressed["ArrowRight"]) { setCritterMoving(pcWolf, movementDirections[1]); }
        } else {
          if (keysPressed["ArrowUp"]) { cameraPY -= cameraSpeed; }
          if (keysPressed["ArrowDown"]) { cameraPY += cameraSpeed; }
          if (keysPressed["ArrowLeft"]) { cameraPX -= cameraSpeed; }
          if (keysPressed["ArrowRight"]) { cameraPX += cameraSpeed; }
          updateCamera();
        }
      }

      updateAllCritters();
      requestAnimationFrame(gameLoop);
    }

    function addCursorTracker() {
      const fieldWrapper = document.getElementById("field-wrapper");
      const cursorCoords = document.getElementById("cursor-coords");

      fieldWrapper.addEventListener("mousemove", (e) => {
        const rect = fieldWrapper.getBoundingClientRect();
        const mousePX = e.clientX - rect.left + cameraPX;
        const mousePY = e.clientY - rect.top + cameraPY;

        const [mouseGX, mouseGY] = rectiProject(mousePX, mousePY);

        // TODO: display out-of-bounds coords in red, normal in black
        if (mouseGX >= 0 && mouseGX < gridWidthN && mouseGY >= 0 && mouseGY < gridHeightN) {
          const [dispGX, dispGY] = [mouseGX.toFixed(3), mouseGY.toFixed(3)];
          cursorCoords.textContent = `x: ${dispGX}, y: ${dispGY}`;
        } else {
          cursorCoords.textContent = `x: –, y: –`;
        }
      });

      fieldWrapper.addEventListener("mouseleave", () => {
        cursorCoords.textContent = `x: –, y: –`;
      });
    }

    function setCritterIdle(wolf) {
      if (wolf.pose === "idle") return;
      wolf.velGX = 0;
      wolf.velGY = 0;
      wolf.nextGX = wolf.gx;
      wolf.nextGY = wolf.gy;
      wolf.pose = "idle";
      updateCritterFrame(mover);
    }

    function setCritterMoving(wolf, dirObj) {
      if (wolf.pose === "walk" && wolf.currentDirection === dirObj.dir) return;
      const visualFitMoveSpeed = 0.08; // TODO: resolve this
      wolf.currentDirection = dirObj.dir;
      wolf.velGX = dirObj.dx * visualFitMoveSpeed;
      wolf.velGY = dirObj.dy * visualFitMoveSpeed;
      wolf.pose = "walk";
      updateCritterFrame(mover);
    }

    function updateCritterAction(wolf) {
      if (wolf === wolves[0] && arrowsMoveWolf) return;

      if (Math.random() < 0.5) {
        setCritterIdle(wolf);
        return;
      }

      const dirObj = movementDirections[Math.floor(Math.random() * movementDirections.length)];
      setCritterMoving(wolf, dirObj);
    }

    function getOccupiedTiles(gx, gy, boxRad = 0.5) {
      const left = Math.floor(gx - boxRad);
      const right = Math.floor(gx + boxRad);
      const top = Math.floor(gy - boxRad);
      const bottom = Math.floor(gy + boxRad);

      const tiles = [];
      for (let x = left; x <= right; x++) {
        for (let y = top; y <= bottom; y++) {
          tiles.push(`${x}_${y}`); // string key
        }
      }
      return tiles;
    }
    

    function doBoundingBoxesOverlap(a, b) {
      // TODO: fix this hardcoded box size
      return Math.abs(a.gx - b.gx) < 32 && Math.abs(a.gy - b.gy) < 32;
    }

    function findCollidingPairs(creatures) {
      // console.log(creatures.map(c => [c.gx, c.gy]));

      const tileMap = new Map();  // key: tile "x_y", value: index of creature
      const potentialPairs = new Set();  // store "i|j" where i < j

      for (let i = 0; i < creatures.length; i++) {
        const creature = creatures[i];
        // TODO: individual-specific bounding boxes, ideally rectangular rather than square
        const tiles = getOccupiedTiles(creature.gx, creature.gy);

        for (const tile of tiles) {
          if (!tileMap.has(tile)) {
            tileMap.set(tile, [i]);
          } else {
            for (const j of tileMap.get(tile)) {
              const pairKey = i < j ? `${i}|${j}` : `${j}|${i}`;
              potentialPairs.add(pairKey);
            }
            tileMap.get(tile).push(i);
          }
        }
      }

      // Now check actual bounding box overlap
      const collisions = [];
      for (const pairKey of potentialPairs) {
        const [i, j] = pairKey.split('|').map(Number);
        if (doBoundingBoxesOverlap(creatures[i], creatures[j])) {
          collisions.push([i, j]);
        }
      }

      return collisions;
    }

    // TODO: fold this into the game loop, so that all critters don't make their decisions simultaneously
    setInterval(() => {
      allCritters.forEach(wolf => updateCritterAction(wolf));
    }, 2000);

    document.addEventListener("keydown", (e) => { keysPressed[e.key] = true; });
    document.addEventListener("keyup", (e) => { keysPressed[e.key] = false; });

    window.onload = function () {
      generateField();
      addCursorTracker();
      gameLoop();
    };
  </script>
</body>
</html>